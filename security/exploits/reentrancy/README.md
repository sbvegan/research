# Reentrancy

One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (aka recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.

## Remediation

The best practices to avoid reentrancy weaknesses are:

- Make sure all internal state changes are performed before the call is executed. This is known as the *Checks-Effects-Interactions* pattern
- Use a reentrancy lock ([Openzeppelin's Reentrancy Guard](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard))
- Use a mutex
    - Be careful to not get caught in a `deadlock` or `livelock`


## Exploits

[List of rentrancy exploits](https://github.com/ethereum/solidity/issues/12996#issuecomment-1187381059)

## Sources

[Consensys - Reentrancy](https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/)
[SWC-107 Reentrancy](https://swcregistry.io/docs/SWC-107)
[Reentrancy After Istanbul](https://blog.openzeppelin.com/reentrancy-after-istanbul/)
[Use the Checks-Effects-Interactions Pattern - Solidity Docs](https://docs.soliditylang.org/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern)
